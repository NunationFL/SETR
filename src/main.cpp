#include <Arduino.h>


#include <avr/interrupt.h>
#include "assembly.h"

#define d1 13 
#define d2 12
#define d3 11
#define d4 10
#define NT 20 //Max number of tasks
#define TICK_FREQUENCY      62
#define STACK_SIZE_DEFAULT  100

typedef struct {
    /* Pointer to the address of the task's 'private' stack in memory */
    volatile uint8_t*   stack_ptr;                 
    /* Size of the allocated stack in bytes */ 
    uint16_t            stack_size;
    uint8_t*            stack_array_ptr;
    /* period in ticks */
    int period;
    /* ticks until next activation */
    int delay;
    /* function pointer */
    void (*func)(void);
    /* activation counter */
    int exec;
    /* task priority */
    int priority;
    /* task scheduling state */ 
    uint8_t state;
} Sched_Task_t;

/** Task states */
enum State {
    READY,     // Ready to be executed 
    RUNNING,   // Currently executing on the processor
    WAITING,   // Task is waiting for a resource to be unlocked, like a mutex
    DONE,      // Task has completed is job. Shifts to TASK_READY in the next activation period
    DEAD       // One-shot tasks that shall not run again
};



//context switching functions
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
uint8_t *pxPortInitialiseStack( uint8_t* pxTopOfStack, void (*pxCode)(), void *pvParameters );
// Definitions from scheduler.ino
void Sched_Init(void);
int Sched_AddT(void (*f)(void), int delay, int period, int priority, int stack_size, uint8_t* stack_start);
void Sched_Schedule(void);
void Sched_Dispatch(void);
void removeTask(int x);
void orderTasks();


#define STACK_CREATE(name, stack_size) \
 uint8_t name##_stack[stack_size];
 

// Global variables
Sched_Task_t Tasks[NT];
uint8_t stacks[NT];
int cur_task = NT;
volatile void* volatile pxCurrentTCB = 0;

/* 4 Tasks:
 *     T1 - T = 100ms   -> Led d1 toggle
 *     T2 - T = 200ms   -> Led d2 toggle
 *     T3 - T = 600ms   -> Led d3 toggle
 *     T4 - T = 100ms   -> Led d4 copied from button A1
 */
void toggle(void) {digitalWrite(d4, !digitalRead(d4));}


void t1(void) {digitalWrite(d1, !digitalRead(d1)); }
void t2(void) {digitalWrite(d2, !digitalRead(d2)); }
void t3(void) {digitalWrite(d3, !digitalRead(d3)); }
void t4(void) {digitalWrite(d4,  digitalRead(A1));}


uint8_t *pxPortInitialiseStack( uint8_t* pxTopOfStack, void (*pxCode)(), void *pvParameters ) {
    uint16_t usAddress;
    /* Simulate how the stack would look after a call to vPortYield() generated by
    the compiler. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    usAddress = ( uint16_t ) pxCode;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( uint8_t ) 0x00;    /* R0 */
    pxTopOfStack--;
    *pxTopOfStack = ( (uint8_t) 0x80 );
    pxTopOfStack--;

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( uint8_t ) 0x00;    /* R1 */

    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( uint8_t ) ( usAddress & ( uint16_t ) 0x00ff );

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;

    return pxTopOfStack;
}


STACK_CREATE(task1, STACK_SIZE_DEFAULT);
STACK_CREATE(task2, STACK_SIZE_DEFAULT);
STACK_CREATE(task3, STACK_SIZE_DEFAULT);


// the setup function runs once when you press reset or power the board
void setup() {

  Serial.begin(9600);
  Serial.write("yo");
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(d4, OUTPUT);
  pinMode(d3, OUTPUT);
  pinMode(d2, OUTPUT);
  pinMode(d1, OUTPUT);

  delay(1000);
  Serial.println((long) &task1_stack, HEX);
  delay(1000);
  Serial.println((long) &task2_stack, HEX);
  delay(1000);
  Serial.println((long) &task3_stack, HEX);
  delay(1000);



  Sched_AddT(t1, 50 /* delay */, 10000 /* period */, 3, STACK_SIZE_DEFAULT, task1_stack);
  Sched_AddT(t2, 50 /* delay */,  10000 /* period */, 2, STACK_SIZE_DEFAULT, task2_stack);
  Sched_AddT(t3, 50 /* delay */,  10000 /* period */, 1, STACK_SIZE_DEFAULT, task3_stack);
  Sched_Init();


  while(true){
    asm("nop");
  }
}

/* Interrupt service routine for the RTOS tick. */
ISR(TIMER1_COMPA_vect, ISR_NAKED){//timer1 interrupt
  /* Call the tick function. */
  vPortYieldFromTick();

  
    //Serial.println("a");

  /* Return from the interrupt. If a context
  switch has occurred this will return to a
  different task. */
  asm volatile ( "reti" );
}

void vPortYieldFromTick( void )
{
  /* This is a naked function so the context
  is saved. */
  portSAVE_CONTEXT();
  /* Increment the tick count and check to see
  if the new tick value has caused a delay
  period to expire. This function call can
  cause a task to become ready to run. */
  Sched_Schedule();
  /* See if a context switch is required.
  Switch to the context of a task made ready
  to run by vTaskIncrementTick() if it has a
  priority higher than the interrupted task. */
  Sched_Dispatch();
  /* Restore the context. If a context switch
  has occurred this will restore the context of
  the task being resumed. */
  portRESTORE_CONTEXT();

  /* Return from this naked function. */
  asm volatile ( "ret" );
}

void Sched_Init(void){
    
    for(int x=0; x<NT; x++)
        Tasks[x].func = 0;
    /* Also configures interrupt that periodically calls Sched_Schedule(). */
    noInterrupts(); // disable all interrupts
    TCCR1A = 0;
    TCCR1B = 0;
    TCNT1 = 0;

    OCR1A = TICK_FREQUENCY;    // compare match register 16MHz/256/2kHz
    TCCR1B |= (1 << WGM12); // CTC mode
    TCCR1B |= (1 << CS12); // 256 prescaler
    TIMSK1 |= (1 << OCIE1A); // enable timer compare interrupt
    interrupts(); // enable all interrupts

    return;

}

int Sched_AddT(void (*f)(void), int delay1, int period, int priority, int stack_size, uint8_t* stack_start){ //TODO ordenar ao adicionar
    for(int x=0; x<NT; x++)
        if (!Tasks[x].func) {
            Tasks[x].period = period;
            Tasks[x].delay = delay1;
            Tasks[x].exec = 0;
            Tasks[x].func = f;
            Tasks[x].priority = priority;
            Tasks[x].stack_ptr = pxPortInitialiseStack(stack_start+stack_size, f, 0);
            Tasks[x].stack_size = stack_size;
            Tasks[x].stack_array_ptr = stack_start;
            Tasks[x].state = DONE;
            orderTasks();
            return x;
        }
    orderTasks();
    return -1;
}


void Sched_Schedule(void){
    
    for(int x=0; x<NT; x++) {
        Serial.println((long) Tasks[x].func, HEX);
        if(Tasks[x].func){
            if(Tasks[x].delay){
                Tasks[x].delay--;
            } else {
                /* Schedule Task */
                Tasks[x].exec++;
                Tasks[x].state = READY;
                Tasks[x].delay = Tasks[x].period-1;

                
            }
        }
    }

    return;
}


void Sched_Dispatch(void){
    //int prev_task = cur_task;

    
    
    for(int x=0; x<NT; x++) {
        if((Tasks[x].func)&&(Tasks[x].state == READY)) {
            if(cur_task==x){
                return;
            }
            Tasks[cur_task].state=WAITING;
            Tasks[x].state=RUNNING;
            cur_task = x;
            pxCurrentTCB = Tasks[x].stack_ptr;
            //delay(1000);
            //Serial.println((long) pxCurrentTCB, HEX);
            //delay(1000);

            
            /* Delete task if one-shot */ //TODO
            // if(!Tasks[x].period) removeTask(x);

            return;
        }
    }
    
}

void removeTask(int x){
    Tasks[x].func = 0;
    for (int i = x+1; i < NT; ++i) {
        Tasks[i-1] = Tasks[i];
    }
    Tasks[NT] = (Sched_Task_t){0};
    return;
}

void orderTasks(){
    int swapped = 1;
    while(swapped){
        swapped = 0;
        for (int i = 0; i < NT-1; ++i) {
            if(Tasks[i].priority < Tasks[i+1].priority){
                Sched_Task_t temp = Tasks[i];
                Tasks[i] = Tasks[i+1];
                Tasks[i+1] = temp;
                swapped = 1;
            }
        }
    }

    return;

}
